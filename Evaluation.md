## Evaluation of the Algorithms
Here is the evaluation of our algorithms.

## Perlin Noise
The key features of the Perlin Noise include gradient vectors, smoothing, linear interpolation, and blending different octaves. Higher octave has higher subdivision of the grid that we generate the noise on. 

Specifically, Suppose we have an $m*n$ grid of heights. In the $l^{th}$ octave, we assign a random point within each cell with random coordinates, and for each vertex we assign a random gradient. Then, we compute the dot product for each gradient vector and the vector from the vertex to the random point in the cell. For each cell, by interpolation and smoothing, we get a section of the "flow" of the surface if viewed the cross section formed by a plane perpendicular to the y-axis(sliced from x-z direction). This "flow" will eventually become the heights when we finish the interpolation and lerping stage for each cell denote as $x_{ijl}$. In the end of each octave, we double the width and length, and multiply a persistence value by a constant $dec\_rate$. If we have $k$ iterations, the final grid will have $(2^km)*(2^kn)$ cells, and each cell has height
$$height_{ij} = \sum_{l=1}^k {dec\_rate}^l x_{\lfloor\frac{i}{2^{k-l}}\rfloor\lfloor\frac{j}{2^{k-l}}\rfloor l}$$

```python
# main part for octave
for i in range(n_row):
    for j in range(n_col):
        heights[i][j] += interpolate(
            # calculate dot products from the random point to the buttom two points in the cell
            # and do interpolate
            interpolate(((random_points[i][j] - Vector(i, j)) * vertex_vectors[i][j]) +
                        noise_scalars[i][j],
                        ((random_points[i][j] - Vector(i, j + 1)) * vertex_vectors[i][j + 1]) +
                        noise_scalars[i][j + 1],
                        smoothing((random_points[i][j] - Vector(i, j)).y)),
            # do the same for the top two points
            interpolate(((random_points[i][j] - Vector(i + 1, j)) * vertex_vectors[i + 1][j]) +
                        noise_scalars[i + 1][j],
                        ((random_points[i][j] - Vector(i + 1, j + 1)) * vertex_vectors[i + 1][j + 1]) +
                        noise_scalars[i + 1][j + 1],
                        smoothing((random_points[i][j] - Vector(i, j)).y)),
            smoothing((random_points[i][j] - Vector(i, j)).x)
        )
```
![Forest landscape generated by Perlin Noise](/asset/Perlin_forest.png)
### Pros of Perlin Noise
- Perlin Noise is highly adaptable and can generate detailed patterns, which means that local changes are supported. As we generally follow the original version of Perlin Noise, we assigned random points in each cell and computed the corresponding dot products, so every "pixel" of the grid is guarunteed to have some form of height and details embedded.

### Cons of Perlin Noise
- On the other side, the iteration in our code that supports the octaves/subdivisions runs exponentially as we recursively subdivide each original cell into four in every subsequent round. The overall time complexity is $O(kmn2^{2k})$, in which `k` is the number of iterations, and `m` and `n` are initial width and length respectively. Compared to the other two algorithms, the extra multiple of `k` in the time complexity makes Perlin Noise relatively slow. 
  
- By the same reason as mentioned above for the random point assignment, the overall pattern generated may be overly crowded and fail to imitate a completely flat terrain/ramp. For example, we cannot generate a wedge nor flat sea surface. 

- To solve the problem of lack of flat terrain, we set a lower threshold for height as the `sea level`, so that every surface with height below this threshold becomes completely flat. 

## Diamond-Square
The Diamond-Square algorithm relies on random values, especially the four corners where the algorithm begins with. In both the "diamond" and "square" part of the algorithm, a random displacement is added to the mean value of the four neighboring values. 

In detail, we have a grid of $(2^n+1)*(2^n+1)$ cells. First, we assign four random values to the four corners. Each step $k$ consists of a `diamond phase` and a `square phase`. In `diamond phase`, we iterate all squares with side length $2^{n-k}$ and calculate the value in the center of the square as the average of the four corners plus a random noise of scale $2^{-k}$. Then in the `square phase`, we iterate all diamonds with diagonal length $2^{n-k}$ and calculate the value in the center of the diamonds as the average of the four corners plus a random noise of scale $2^{-k}$. Repeat the step $n$ times, until every cell in the grid has a value assigned. 

```python
# implementation of diamond-square
for i in range(n):
    step_width = 1 << (n-i-1)
    # diamond phase
    for j in range(1 << i):
        for k in range(1 << i):
            x_cor = step_width * (2*j+1)
            y_cor = step_width * (2*k+1)
            heights[x_cor][y_cor] = diamond_average(x_cor,y_cor,step_width) + \
                random.uniform(-random_range, random_range)

    # square phase
    for j in range(1 << i):
        for k in range(1 << i):
            x_cor = step_width * (2*j+1)
            y_cor = step_width * (2*k)
            heights[x_cor][y_cor] = square_average(x_cor,y_cor,step_width) + \
                random.uniform(-random_range, random_range)
            heights[y_cor][x_cor] = square_average(y_cor,x_cor,step_width) + \
                random.uniform(-random_range, random_range)

    # boundaries of square phase
    for j in range(1 << i):
        x_cor = step_width * (2 * j + 1)
        y_cor = HeightMapWidth-1
        heights[x_cor][y_cor] = square_average(x_cor, y_cor, step_width) + \
            random.uniform(-random_range, random_range)
        heights[y_cor][x_cor] = square_average(y_cor, x_cor, step_width) + \
            random.uniform(-random_range, random_range)
```

![Moon surface terrain generated by Diamond Square](/asset/DS_moon.png)

### Pros of Diamond Square
- The algorithm runs much faster than the Perlin Noise, because it only depends on how many cells we subdivide the grid upon initialization and there is no recursion going on, and the value at each vertex in the grid is calculated exactly once. Its time complexity is $O(2^{2n})$, where $n$ is the number of iterations. 

- Moreover, the algorithm is flexible in the sense that we can generate extremely different terrains by only changing a few parameters of the algorithm (i.e, the initialization point of the four corners, the random displacement range, etc). 

### Cons of Diamond Square
- Since we are computing the mean for both steps, the height of the terrain at each point depends heavily on the random displacement added and it is also less likely to have many small "mountains" in the terrain, rather, it shows a gradual flow due to our control on the random displacement range. In particular, the initial values of the four corners have huge influence on the final landscape we generate.

## Worley (Voronoi) Noise
We had two versions of Worley noise, one relied on the built-in geometry node and texture in blender while we built the other one from scractch. For both methods, the terrain generated tend to have the "cell" look of a 2D Voronoi diagram if viewed from the top orthographic direction. However, for the full blender version, it is less easy to tell when the "detail" parameter increases. As for our own version, with careful blending of the "smoothing function" from the Perlin Noise and "extra weight" added to each Voronoi cell, we were able to create cells with different sizes, which adds variability to the final display. 
Due to the nature of the voronoi diagram, the terrain generated looks much different to the other two noises, mostly in terms of shape as well as height. For our own version, we added the similar skill of cropping the "sea level" to reduce the "troughs" created by the original Worley noise.

```python
# calculate the minimum distance for closest site for each pixel
for i in range(resolution):
    for j in range(resolution):
        grid_x = i//n
        grid_y = j//n
        coord_x = i*1.0/n
        coord_y = j*1.0/n
        dists = []
        for k in [-1, 0, 1]:
            for l in [-1, 0, 1]:
                x = grid_x + k
                y = grid_y + l
                if 0 <= x < width and 0 <= y < width:
                    dists.append(depths[i][j] + weights[i][j] * 
                        math.sqrt((grid[x][y][0] - coord_x)**2 + (grid[x][y][1] - coord_y)**2))
        distances[i][j] = min(1, min(dists))

# update height of every pixel
for i in range(resolution):
    for j in range(resolution):
        pixels[i][j] += smoothing(distances[i][j]) * z
```

![Blood Tissue sample generated by Voronoi (Worley) Noise](/asset/worley.png)

### Pros of Worley Noise
- The algorithm produces relatively consistent patterns for each run, so if we wanted an algorithm that will generate terrains with less variability, this might be a better choice than the previous two. Due to the nature of the Voronoi diagram, it has a more circular shape of every trough and a less smooth peak formed by the equidistance line between the cells, which is indeed very unique.

### Cons of Worley Noise
- The Worley noise is less adaptable and requires much math to alternate its fundamental shape. The edge formed by the equidistance line is also sharp and requires additional smoothing procedure.

## Something Else That We Want To Say...
All the algorithms above achieve the goal of generating a terrain that imitates a landscape: there are heights and by using different colors we create different meanings for different levels of height. Mostly we color the terrain (from low to high) in terms of sea, land, mountain, and snow on the mountain, but we are also able to generate different kinds of landscapes, such as desert or volcano. 
However, perhaps due to the nature of these algorithms, so far we are unable to mimic a river without using non-algorithmic tools from blender itself to generate rivers, or anything that have a more "global feature" that we can tell by just looking at the terrain generated. We are able to generate mass portion of sea with blobs of islands and we are able to genereate vast grassland with a few ponds. We hope to be able to achieve this in the near future with algorithms.

## References


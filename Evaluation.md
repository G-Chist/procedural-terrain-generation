## Evaluation of the Algorithms
Here is the evaluation of our algorithms.

## Perlin Noise
The key features of the Perlin Noise include gradient vectors, smoothing, linear interpolation, and blending different octaves. Higher octave has higher subdivision of the grid that we generate the noise on. 

Specifically, Suppose we have an $m*n$ grid of heights. In the $l^{th}$ octave, we assign a random point within each cell with random coordinates, and for each vertex we assign a random gradient. Then, we compute the dot product for each gradient vector and the vector from the vertex to the random point in the cell. For each cell, by interpolation and smoothing, we get a section of the "flow" of the surface if viewed the cross section formed by a plane perpendicular to the y-axis(sliced from x-z direction). This "flow" will eventually become the heights when we finish the interpolation and lerping stage for each cell denote as $x_{ijl}$. In the end of each octave, we double the width and length, and multiply a persistence value by a constant $dec\_rate$. If we have $k$ iterations, the final grid will have $(2^km)*(2^kn)$ cells, and each cell has height
$$height_{ij} = \sum_{l=1}^k {dec\_rate}^l x_{\lfloor\frac{i}{2^{k-l}}\rfloor\lfloor\frac{j}{2^{k-l}}\rfloor l}$$

```python
# main part for octave
for i in range(n_row):
    for j in range(n_col):
        heights[i][j] += interpolate(
            # calculate dot products from the random point to the buttom two points in the cell
            # and do interpolate
            interpolate(((random_points[i][j] - Vector(i, j)) * vertex_vectors[i][j]) +
                        noise_scalars[i][j],
                        ((random_points[i][j] - Vector(i, j + 1)) * vertex_vectors[i][j + 1]) +
                        noise_scalars[i][j + 1],
                        smoothing((random_points[i][j] - Vector(i, j)).y)),
            # do the same for the top two points
            interpolate(((random_points[i][j] - Vector(i + 1, j)) * vertex_vectors[i + 1][j]) +
                        noise_scalars[i + 1][j],
                        ((random_points[i][j] - Vector(i + 1, j + 1)) * vertex_vectors[i + 1][j + 1]) +
                        noise_scalars[i + 1][j + 1],
                        smoothing((random_points[i][j] - Vector(i, j)).y)),
            smoothing((random_points[i][j] - Vector(i, j)).x)
        )
```

### Pros of Perlin Noise
- Perlin Noise is highly adaptable and can generate detailed patterns, which means that local changes are supported. As we generally follow the original version of Perlin Noise, we assigned random points in each cell and computed the corresponding dot products, so every "pixel" of the grid is guarunteed to have some form of height and details embedded.

### Cons of Perlin Noise
- On the other side, the iteration in our code that supports the octaves/subdivisions runs exponentially as we recursively subdivide each original cell into four in every subsequent round. The overall time complexity is $O(kmn2^{2k})$, in which `k` is the number of iterations, and `m` and `n` are initial width and length respectively. Compared to the other two algorithms, the extra multiple of `k` in the time complexity makes Perlin Noise relatively slow. 

- It requires some extra efforts to combine different layers of octaves, in order to avoid apparent "contour lines" in the generated terrain. 
  
- By the same reason as mentioned above for the random point assignment, the overall pattern generated may be overly crowded and fail to imitate a completely flat terrain/ramp. For example, we cannot generate a wedge nor flat sea surface. 

- To solve the problem of lack of flat terrain, we set a lower threshold for height as the `sea level`, so that every surface with height below this threshold becomes completely flat. 

### Applications of Perlin Noise
Among the three generation algorithms, Perlin Noise is the one used in realistic terrain generation most, due to its high adaptability and irregularity of patterns generated. One example is the forest landscape as below:

![Forest landscape generated by Perlin Noise](/asset/Perlin_forest.png)

## Diamond-Square
The Diamond-Square algorithm relies on random values, especially the four corners where the algorithm begins with. In both the "diamond" and "square" part of the algorithm, a random displacement is added to the mean value of the four neighboring values. 

In detail, we have a grid of $(2^n+1)*(2^n+1)$ cells. First, we assign four random values to the four corners. Each step $k$ consists of a `diamond phase` and a `square phase`. In `diamond phase`, we iterate all squares with side length $2^{n-k}$ and calculate the value in the center of the square as the average of the four corners plus a random noise of scale $2^{-k}$. Then in the `square phase`, we iterate all diamonds with diagonal length $2^{n-k}$ and calculate the value in the center of the diamonds as the average of the four corners plus a random noise of scale $2^{-k}$. Repeat the step $n$ times, until every cell in the grid has a value assigned. 

```python
# implementation of diamond-square
for i in range(n):
    step_width = 1 << (n-i-1)
    # diamond phase
    for j in range(1 << i):
        for k in range(1 << i):
            x_cor = step_width * (2*j+1)
            y_cor = step_width * (2*k+1)
            heights[x_cor][y_cor] = diamond_average(x_cor,y_cor,step_width) + \
                random.uniform(-random_range, random_range)

    # square phase
    for j in range(1 << i):
        for k in range(1 << i):
            x_cor = step_width * (2*j+1)
            y_cor = step_width * (2*k)
            heights[x_cor][y_cor] = square_average(x_cor,y_cor,step_width) + \
                random.uniform(-random_range, random_range)
            heights[y_cor][x_cor] = square_average(y_cor,x_cor,step_width) + \
                random.uniform(-random_range, random_range)

    # boundaries of square phase
    for j in range(1 << i):
        x_cor = step_width * (2 * j + 1)
        y_cor = HeightMapWidth-1
        heights[x_cor][y_cor] = square_average(x_cor, y_cor, step_width) + \
            random.uniform(-random_range, random_range)
        heights[y_cor][x_cor] = square_average(y_cor, x_cor, step_width) + \
            random.uniform(-random_range, random_range)
```

### Pros of Diamond Square
- The algorithm runs much faster than the Perlin Noise, because it only depends on how many cells we subdivide the grid upon initialization and there is no recursion going on, and the value at each vertex in the grid is calculated exactly once. Its time complexity is $O(2^{2n})$, where $n$ is the number of iterations. 

- Moreover, the algorithm is flexible in the sense that we can generate extremely different terrains by only changing a few parameters of the algorithm (i.e, the initialization point of the four corners, the random displacement range, etc). 

### Cons of Diamond Square
- Since we are computing the mean for both steps, the height of the terrain at each point depends heavily on the random displacement added and it is also less likely to have many small "mountains" in the terrain, rather, it shows a gradual flow due to our control on the random displacement range. In particular, the initial values of the four corners have huge influence on the final landscape we generate.

### Applications

Due to its relatively less time complexity, Diamond Square is usually used in quick generation, or generation of dynamic patterns, and it is relatively easy to generate a large coarse surface without hills using this algorithm. For example, we used it to generate a moon surface terrain:
![Moon surface terrain generated by Diamond Square](/asset/DS_moon.png)

## Worley (Voronoi) Noise
We had two versions of Worley noise, one relied on the built-in geometry node and texture in blender while we built the other one from scractch. For both methods, the terrain generated tend to have the "cell" look of a 2D Voronoi diagram if viewed from the top orthographic direction. However, for the full blender version, it is less easy to tell when the "detail" parameter increases. As for our own version, with careful blending of the "smoothing function" from the Perlin Noise and "extra weight" added to each Voronoi cell, we were able to create cells with different sizes, which adds variability to the final display. 
Due to the nature of the voronoi diagram, the terrain generated looks much different to the other two noises, mostly in terms of shape as well as height. For our own version, we added the similar skill of cropping the "sea level" to reduce the "troughs" created by the original Worley noise.

```python
# calculate the minimum distance for closest site for each pixel
for i in range(resolution):
    for j in range(resolution):
        grid_x = i//n
        grid_y = j//n
        coord_x = i*1.0/n
        coord_y = j*1.0/n
        dists = []
        for k in [-1, 0, 1]:
            for l in [-1, 0, 1]:
                x = grid_x + k
                y = grid_y + l
                if 0 <= x < width and 0 <= y < width:
                    dists.append(depths[i][j] + weights[i][j] * 
                        math.sqrt((grid[x][y][0] - coord_x)**2 + (grid[x][y][1] - coord_y)**2))
        distances[i][j] = min(1, min(dists))

# update height of every pixel
for i in range(resolution):
    for j in range(resolution):
        pixels[i][j] += smoothing(distances[i][j]) * z
```

### Pros of Worley Noise
- The algorithm produces relatively consistent patterns for each run, so if we wanted an algorithm that will generate terrains with less variability, this might be a better choice than the previous two. Due to the nature of the Voronoi diagram, it has a more circular shape of every trough and a less smooth peak formed by the equidistance line between the cells, which is indeed very unique.

### Cons of Worley Noise
- The Worley noise is less adaptable and requires much math to alternate its fundamental shape. The edge formed by the equidistance line is also sharp and requires additional smoothing procedure.

### Applications of Worley Noise
Because the patterns generated by Worley Noise are relatively regular, this algorithm is commonly used in generating repetitive or porous surfaces. For example, we generated the following tissue sample using Worley Noise:
![Tissue sample generated by Voronoi (Worley) Noise](/asset/worley.png)

## Something Else That We Want To Say...
All the algorithms above achieve the goal of generating a terrain that imitates a landscape: there are heights and by using different colors we create different meanings for different levels of height. Mostly we color the terrain (from low to high) in terms of sea, land, mountain, and snow on the mountain, but we are also able to generate different kinds of landscapes, such as desert or volcano. 
However, perhaps due to the nature of these algorithms, so far we are unable to mimic a river without using non-algorithmic tools from blender itself to generate rivers, or anything that have a more "global feature" that we can tell by just looking at the terrain generated. We are able to generate mass portion of sea with blobs of islands and we are able to genereate vast grassland with a few ponds. We hope to be able to achieve this in the near future with algorithms.

## Potential Future Works:
We are currently exploring more detailed metrics that can allow us to quantify how well our terrain is generated by our algorithms and also hoping to develop new procedural algorithms that combine existing algorithms with slight twists of our own that will have more flexibility and details at certain portions of the terrain instead of a “uniform” change across the whole terrain. On the tool side, we are exploring more creative ways to add color to the terrains instead of only assigning color based on height (which is what we are using at this current moment with the help of the color ramp) as well as understanding how extra rendering parameters in Blender may help us enhance the visualization part of our project.

We would also love to hear feedbacks and suggestions. We can be reached by the following email addresses:
Caroline Yao: zyao1@swarthmore.edu
Yue Zhang: yzhang4@swarthmore.edu (graduating soon) / yuezhang1437@gmail.com

## Acknowledgement:
We want to thank Professor Neil Lutz for supervising our project and giving us constructive feedback frequently. We would also like to thank friends and family who have reviewed our project at its early stages and gave us suggestions. We are truly grateful for everyone that has supported us along the way.

## References
- The book of shaders. The Book of Shaders. (n.d.). https://thebookofshaders.com/12/ 
- The Diamond Square algorithm. (n.d.). https://learn.64bitdragon.com/articles/computer-science/procedural-generation/the-diamond-square-algorithm 
- Frade, M., de Vega, F. F., &amp; Cotta, C. (2012). Automatic evolution of programs for procedural generation of terrains for video games. Soft Computing, 16(11), 1893–1914. https://doi.org/10.1007/s00500-012-0863-z 
- Interview: Ken Perlin, professor, Media Research Laboratory, Courant Institute of Mathematical Sciences, New York University. (2015). Digital Character Development, 309–312. https://doi.org/10.1201/b18917-43 
- Lagae, A., Lefebvre, S., Cook, R., DeRose, T., Drettakis, G., Ebert, D. S., Lewis, J. P., Perlin, K., &amp; Zwicker, M. (2010). A survey of procedural noise functions. Computer Graphics Forum, 29(8), 2579–2600. https://doi.org/10.1111/j.1467-8659.2010.01827.x 
- Latif, A., Zuhairi, M. F., Khan, F. Q., Randhawa, P., &amp; Patel, A. (2022). A critical evaluation of Procedural Content Generation Approaches for Digital Twins. Journal of Sensors, 2022, 1–13. https://doi.org/10.1155/2022/5629645 
- Mount, D., &amp; Eastman, R. (n.d.). Procedural Generation: 2D Perlin Noise. https://www.cs.umd.edu/class/spring2018/cmsc425/Lects/lect13-2d-perlin.pdf 
- Worley, S. (1996). A cellular texture basis function. Proceedings of the 23rd Annual Conference on Computer Graphics and Interactive Techniques. https://doi.org/10.1145/237170.237267 
- YouTube. (2022, August 15). How to turn a few numbers into worlds (Fractal Perlin Noise). YouTube. https://www.youtube.com/watch?v=ZsEnnB2wrbI&amp;t=0s 
- YouTube. (2023, October 17). Add noise to objects using geometry nodes | blender tutorial | VFX_Blend. YouTube. https://www.youtube.com/watch?v=Ev4fMp79Xv0
